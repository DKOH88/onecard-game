<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì›ì¹´ë“œ ì˜¨ë¼ì¸ ğŸƒ</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Noto Sans KR', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a472a 0%, #0d2818 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            color: white;
            overflow-x: hidden;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* ë¡œë¹„ ìŠ¤íƒ€ì¼ */
        .lobby-container {
            background: rgba(0, 0, 0, 0.5);
            padding: 30px;
            border-radius: 20px;
            max-width: 500px;
            width: 100%;
            margin-top: 50px;
        }

        .lobby-container h2 {
            text-align: center;
            margin-bottom: 20px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #60a5fa, #3b82f6);
            color: white;
        }

        .btn:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .room-code-display {
            font-size: 2.5rem;
            font-weight: bold;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 15px 0;
            letter-spacing: 5px;
        }

        .player-list {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-item:last-child {
            border-bottom: none;
        }

        .player-item.host::after {
            content: 'ğŸ‘‘';
            margin-left: 5px;
        }

        .player-item.me {
            background: rgba(74, 222, 128, 0.2);
            border-radius: 5px;
        }

        .connection-status {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4ade80;
        }

        .connection-status.offline {
            background: #ef4444;
        }

        /* ê²Œì„ ì˜ì—­ ìŠ¤íƒ€ì¼ (ê¸°ì¡´ê³¼ ë™ì¼) */
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 900px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .direction-indicator {
            font-size: 1.3rem;
            padding: 5px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .game-table {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 600px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .player-slot {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s;
        }

        .player-slot.top {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .player-slot.bottom {
            bottom: -60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }

        .player-slot.left {
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .player-slot.right {
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        .player-slot.top-left {
            top: 10%;
            left: 10%;
        }

        .player-slot.top-right {
            top: 10%;
            right: 10%;
        }

        .player-area {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px 25px;
            border-radius: 15px;
            min-width: 200px;
        }

        .player-area.current-turn {
            box-shadow: 0 0 20px #4ade80;
            border: 2px solid #4ade80;
        }

        .player-label {
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .card-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.85rem;
        }

        .cards-row {
            display: flex;
            gap: 0;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 800px;
        }

        .card {
            width: 50px !important;
            height: 70px !important;
            flex-shrink: 0 !important;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            margin-left: -30px !important;
            border: 1px solid #333;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
            font-size: 0.65rem;
            opacity: 0.95;
            /* ê¸°ë³¸ íˆ¬ëª…ë„ */
            background-color: white;
            /* íˆ¬ëª…ë„ ì ìš© ì‹œ ë°°ê²½ í•„ìš” */
            background-size: 100% 100%;
            /* ì´ë¯¸ì§€ í¬ê¸° ìë™ ë§ì¶¤ */
            background-repeat: no-repeat;
            background-position: center;
        }

        .card:first-child {
            margin-left: 0;
        }

        .card:hover:not(.disabled) {
            transform: translateY(-10px);
            z-index: 10;
            opacity: 1 !important;
            /* í˜¸ë²„ ì‹œ ë¶ˆíˆ¬ëª… */
        }

        .card.selected {
            transform: translateY(-20px);
            box-shadow: 0 0 15px #4ade80;
            border-color: #4ade80;
            opacity: 1 !important;
            /* ì„ íƒ ì‹œ ë¶ˆíˆ¬ëª… */
        }

        .card.playable:not(.selected) {
            border: 2px solid #4ade80 !important;
            box-shadow: 0 0 10px #4ade80;
        }

        .card-back {
            background: linear-gradient(135deg, #1e3a5f, #0f1f35);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .card-back::after {
            content: 'ğŸƒ';
        }

        /* ì¹´ë“œ ì´ë¯¸ì§€ ìŠ¤íƒ€ì¼ */
        .card.spade,
        .card.club,
        .card.heart,
        .card.diamond {
            background-size: 92%;
            background-position: center;
            background-repeat: no-repeat;
            color: transparent;
            text-shadow: none;
            background-color: white;
            border-radius: 6px;
        }

        .card.spade.val-A {
            background-image: url('cards/spade/A.png');
        }

        .card.spade.val-2 {
            background-image: url('cards/spade/2.png');
        }

        .card.spade.val-3 {
            background-image: url('cards/spade/3.png');
        }

        .card.spade.val-4 {
            background-image: url('cards/spade/4.png');
        }

        .card.spade.val-5 {
            background-image: url('cards/spade/5.png');
        }

        .card.spade.val-6 {
            background-image: url('cards/spade/6.png');
        }

        .card.spade.val-7 {
            background-image: url('cards/spade/7.png');
        }

        .card.spade.val-8 {
            background-image: url('cards/spade/8.png');
        }

        .card.spade.val-9 {
            background-image: url('cards/spade/9.png');
        }

        .card.spade.val-10 {
            background-image: url('cards/spade/10.png');
        }

        .card.spade.val-J {
            background-image: url('cards/spade/J.png');
        }

        .card.spade.val-Q {
            background-image: url('cards/spade/Q.png');
        }

        .card.spade.val-K {
            background-image: url('cards/spade/K.png');
        }

        .card.club.val-A {
            background-image: url('./cards/club/A.jpg?v=999');
        }

        .card.club.val-2 {
            background-image: url('./cards/club/2.jpg?v=999');
        }

        .card.club.val-3 {
            background-image: url('./cards/club/3.jpg?v=999');
        }

        .card.club.val-4 {
            background-image: url('./cards/club/4.jpg?v=999');
        }

        .card.club.val-5 {
            background-image: url('./cards/club/5.jpg?v=999');
        }

        .card.club.val-6 {
            background-image: url('./cards/club/6.jpg?v=999');
        }

        .card.club.val-7 {
            background-image: url('./cards/club/7.jpg?v=999');
        }

        .card.club.val-8 {
            background-image: url('./cards/club/8.jpg?v=999');
        }

        .card.club.val-9 {
            background-image: url('./cards/club/9.jpg?v=999');
        }

        .card.club.val-10 {
            background-image: url('./cards/club/10.jpg?v=999');
        }

        .card.club.val-J {
            background-image: url('./cards/club/J.jpg?v=999');
        }

        .card.club.val-Q {
            background-image: url('./cards/club/Q.jpg?v=999');
        }

        .card.club.val-K {
            background-image: url('./cards/club/K.jpg?v=999');
        }

        .card.heart.val-A {
            background-image: url('cards/heart/A.png');
        }

        .card.heart.val-2 {
            background-image: url('cards/heart/2.png');
        }

        .card.heart.val-3 {
            background-image: url('cards/heart/3.png');
        }

        .card.heart.val-4 {
            background-image: url('cards/heart/4.png');
        }

        .card.heart.val-5 {
            background-image: url('cards/heart/5.png');
        }

        .card.heart.val-6 {
            background-image: url('cards/heart/6.png');
        }

        .card.heart.val-7 {
            background-image: url('cards/heart/7.png');
        }

        .card.heart.val-8 {
            background-image: url('cards/heart/8.png');
        }

        .card.heart.val-9 {
            background-image: url('cards/heart/9.png');
        }

        .card.heart.val-10 {
            background-image: url('cards/heart/10.png');
        }

        .card.heart.val-J {
            background-image: url('cards/heart/J.png');
        }

        .card.heart.val-Q {
            background-image: url('cards/heart/Q.png');
        }

        .card.heart.val-K {
            background-image: url('cards/heart/K.png');
        }

        .card.diamond.val-A {
            background-image: url('cards/diamond/A.png');
        }

        .card.diamond.val-2 {
            background-image: url('cards/diamond/2.png');
        }

        .card.diamond.val-3 {
            background-image: url('cards/diamond/3.png');
        }

        .card.diamond.val-4 {
            background-image: url('cards/diamond/4.png');
        }

        .card.diamond.val-5 {
            background-image: url('cards/diamond/5.png');
        }

        .card.diamond.val-6 {
            background-image: url('cards/diamond/6.png');
        }

        .card.diamond.val-7 {
            background-image: url('cards/diamond/7.png');
        }

        .card.diamond.val-8 {
            background-image: url('cards/diamond/8.png');
        }

        .card.diamond.val-9 {
            background-image: url('cards/diamond/9.png');
        }

        .card.diamond.val-10 {
            background-image: url('cards/diamond/10.png');
        }

        .card.diamond.val-J {
            background-image: url('cards/diamond/J.png');
        }

        .card.diamond.val-Q {
            background-image: url('cards/diamond/Q.png');
        }

        .card.diamond.val-K {
            background-image: url('cards/diamond/K.png');
        }

        .card.black-joker {
            background: url('cards/black_joker.png') center/contain no-repeat;
            background-color: white;
            color: transparent;
        }

        .card.color-joker {
            background: url('cards/color_joker.png') center/contain no-repeat;
            background-color: white;
            color: transparent;
        }

        .center-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-top: 60px;
            z-index: 50;
            position: relative;
        }

        .deck-area {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .deck {
            position: fixed !important;
            bottom: 30px;
            left: 30px;
            width: 40px;
            height: 55px;
            z-index: 100;
            cursor: pointer;
        }

        .deck::after {
            content: 'ì¹´ë“œ ë°›ê¸°';
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 10px;
            white-space: nowrap;
            text-shadow: 1px 1px 2px black;
        }

        .deck .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: pointer;
            background: url('cards/card_back_custom.jpg') center/cover no-repeat !important;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            border-radius: 8px;
        }

        .deck.highlight {
            box-shadow: 0 0 20px #4ade80 !important;
            border: 4px solid #4ade80 !important;
            animation: pulse-green 1s infinite;
        }

        @keyframes pulse-green {
            0% {
                transform: scale(1);
                box-shadow: 0 0 20px #4ade80;
            }

            50% {
                transform: scale(1.1);
                box-shadow: 0 0 40px #4ade80;
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 20px #4ade80;
            }
        }

        @keyframes bounce-green {

            0%,
            100% {
                transform: translateY(0);
                box-shadow: 0 0 5px #4ade80;
            }

            50% {
                transform: translateY(-6px);
                box-shadow: 0 0 15px #4ade80;
            }
        }

        .discard-pile {
            display: flex;
            align-items: center;
        }

        .direction-indicator {
            font-size: 0.9rem !important;
            opacity: 0.8;
        }

        #discard-cards {
            display: flex;
            align-items: center;
        }

        .message-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.1rem;
            text-align: center;
            min-width: 200px;
        }

        .message-box.attack {
            background: linear-gradient(135deg, #dc2626, #991b1b);
            animation: pulse 0.5s infinite alternate;
        }

        @keyframes pulse {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.05);
            }
        }

        .action-buttons {
            display: none;
            gap: 10px;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            flex-direction: column;
        }

        /* ìƒëŒ€ë°© ì¹´ë“œ (ì‘ê²Œ) */
        .opponent-card {
            width: 30px !important;
            height: 42px !important;
            margin-left: -18px !important;
            font-size: 0.6rem !important;
        }

        .opponent-card:first-child {
            margin-left: 0 !important;
        }

        /* ìƒëŒ€ë°© ì¹´ë“œ ì˜ì—­ */
        .opponent-area {
            min-width: auto !important;
        }

        .opponent-area .cards-row {
            max-width: 120px !important;
            flex-wrap: wrap !important;
            gap: 0 !important;
            /* ê°­ ì œê±° */
            justify-content: center !important;
            padding-left: 10px;
        }

        .opponent-area .card {
            margin-left: -22px !important;
            /* ê°€ë¡œ ê²¹ì¹˜ê¸° */
            margin-bottom: -30px !important;
            /* ì„¸ë¡œ ê²¹ì¹˜ê¸° */
            box-shadow: -1px 0 2px rgba(0, 0, 0, 0.3);
            /* ê·¸ë¦¼ìë¡œ êµ¬ë¶„ */
        }

        .opponent-area .card:first-child {
            margin-left: 0 !important;
        }

        .opponent-area .opponent-card {
            margin-left: 0 !important;
            margin-bottom: 3px;
        }

        .version-badge {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            margin-top: 20px;
        }

        .suit-selector {
            display: none;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }

        .suit-btn {
            font-size: 2rem;
            padding: 15px 25px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            background: white;
        }

        .hidden {
            display: none !important;
        }

        /* ë°˜ì‘í˜• */
        @media (max-width: 600px) {
            .game-table {
                height: 500px;
            }

            .card {
                width: 40px;
                height: 56px;
            }
        }
    </style>
</head>

<body>
    <h1>ğŸƒ ì›ì¹´ë“œ ì˜¨ë¼ì¸</h1>

    <!-- ë¡œë¹„ í™”ë©´ -->
    <div class="lobby-container" id="lobby-screen">
        <h2>ğŸ® ê²Œì„ ë¡œë¹„</h2>
        <div class="version-badge">v2.2.8</div>

        <div id="main-menu">
            <div class="input-group">
                <label>ë‹‰ë„¤ì„</label>
                <input type="text" id="nickname-input" placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
            </div>

            <p style="text-align:center; margin: 15px 0 5px; font-weight:bold; color:#4ade80;">ì˜¨ë¼ì¸ ë©€í‹°í”Œë ˆì´</p>
            <button class="btn btn-primary" onclick="createRoom()">ğŸ  ë°© ë§Œë“¤ê¸°</button>
            <button class="btn btn-secondary" onclick="showJoinForm()">ğŸšª ë°© ì°¸ê°€í•˜ê¸°</button>

            <p style="text-align:center; margin: 20px 0 5px; font-weight:bold; color:#fbbf24;">ì‹±ê¸€ í”Œë ˆì´ì–´</p>
            <button class="btn" style="background:linear-gradient(135deg,#fbbf24,#f59e0b);color:#000;"
                onclick="showSinglePlayerForm()">ğŸ¤– AIì™€ ëŒ€ì „</button>
        </div>

        <div id="single-player-form" class="hidden">
            <div class="input-group">
                <label>AI ìƒëŒ€ ìˆ˜ (1~5ëª…)</label>
                <select id="ai-count-select" style="width:100%;padding:12px;border-radius:10px;font-size:1rem;">
                    <option value="1">1ëª… (1:1 ëŒ€ì „)</option>
                    <option value="2">2ëª…</option>
                    <option value="3" selected>3ëª… (ì¶”ì²œ)</option>
                    <option value="4">4ëª…</option>
                    <option value="5">5ëª… (ìµœëŒ€)</option>
                </select>
            </div>
            <button class="btn btn-primary" onclick="startSinglePlayer()">ğŸ® ê²Œì„ ì‹œì‘</button>
            <button class="btn btn-secondary" onclick="hideSinglePlayerForm()">ì·¨ì†Œ</button>
        </div>

        <div id="join-form" class="hidden">
            <div class="input-group">
                <label>ë°© ì½”ë“œ</label>
                <input type="number" id="room-code-input" placeholder="4ìë¦¬ ìˆ«ì ì½”ë“œ" maxlength="4"
                    style="text-transform: uppercase;"
                    oninput="if(this.value.length > 4) this.value = this.value.slice(0, 4);">
            </div>
            <button class="btn btn-primary" onclick="joinRoom()">ì°¸ê°€í•˜ê¸°</button>
            <button class="btn btn-secondary" onclick="hideJoinForm()">ì·¨ì†Œ</button>
        </div>

        <div id="waiting-room" class="hidden">
            <div class="room-code-display" id="room-code-display">------</div>
            <p style="text-align:center;margin-bottom:10px;">ì¹œêµ¬ì—ê²Œ ì´ ì½”ë“œë¥¼ ê³µìœ í•˜ì„¸ìš”!</p>

            <div class="player-list" id="player-list">
                <!-- í”Œë ˆì´ì–´ ëª©ë¡ì´ ì—¬ê¸°ì— í‘œì‹œë¨ -->
            </div>

            <div id="host-controls" class="hidden">
                <button class="btn btn-primary" onclick="startOnlineGame()" id="start-game-btn" disabled>
                    ğŸ® ê²Œì„ ì‹œì‘ (ìµœì†Œ 2ëª… í•„ìš”)
                </button>
            </div>

            <button class="btn btn-secondary" onclick="leaveRoom()">ğŸšª ë‚˜ê°€ê¸°</button>
        </div>
    </div>

    <!-- ê²Œì„ í™”ë©´ -->
    <div id="game-screen" class="hidden" style="width:100%;max-width:900px;">
        <div class="game-header">
            <div>
                <span id="turn-text">ëŒ€ê¸° ì¤‘...</span>
            </div>
            <div class="direction-indicator" id="direction">âŸ³ ì‹œê³„</div>
            <div>
                <span id="deck-count">ë±: 0</span>
            </div>
        </div>

        <div class="game-table">
            <div class="player-slot top" id="slot-top"></div>
            <div class="player-slot left" id="slot-left"></div>
            <div class="player-slot right" id="slot-right"></div>
            <div class="player-slot top-left" id="slot-top-left"></div>
            <div class="player-slot top-right" id="slot-top-right"></div>

            <div class="center-area">
                <div class="deck-area">
                    <div class="deck" onclick="drawCardOnline()">
                        <div class="card-back"></div>
                    </div>
                    <div class="discard-pile" id="discard-cards"></div>
                </div>
                <div class="message-box" id="message">ê²Œì„ ì‹œì‘!</div>
                <div class="action-buttons" id="action-buttons">
                    <button class="btn btn-primary" onclick="playSelectedCardsOnline()">ì¹´ë“œ ë‚´ê¸°</button>
                    <button class="btn btn-secondary" onclick="clearSelection()">ì·¨ì†Œ</button>
                </div>
            </div>

            <div class="player-slot bottom" id="slot-bottom"></div>
        </div>
    </div>

    <!-- ë¬´ëŠ¬ ì„ íƒ -->
    <div class="suit-selector" id="suit-selector">
        <button class="suit-btn" style="color:#000;" onclick="selectSuitOnline('spade')">â™ </button>
        <button class="suit-btn" style="color:#e11d48;" onclick="selectSuitOnline('heart')">â™¥</button>
        <button class="suit-btn" style="color:#e11d48;" onclick="selectSuitOnline('diamond')">â™¦</button>
        <button class="suit-btn" style="color:#000;" onclick="selectSuitOnline('club')">â™£</button>
    </div>

    <script>
        // Firebase ì„¤ì •
        const firebaseConfig = {
            databaseURL: "https://dkcard-89e9c-default-rtdb.asia-southeast1.firebasedatabase.app"
        };
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // ê²Œì„ ìƒíƒœ
        let myPlayerId = null;
        let myNickname = '';
        let currentRoomCode = null;
        let isHost = false;
        let roomRef = null;
        let gameState = null;
        let players = [];
        let selectedCards = [];
        let lastTurnIndex = -1; // í„´ ë³€ê²½ ê°ì§€ìš©

        // ì•Œë¦¼ìŒ ìƒì„±
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        function playTurnSound() {
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // A5
                oscillator.frequency.setValueAtTime(1175, audioContext.currentTime + 0.1); // D6

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.log('Sound not available');
            }
        }

        function playShuffleSound() {
            try {
                // ì¹´ë“œ ì…”í”Œ íš¨ê³¼ìŒ (ë¹ ë¥¸ ë…¸ì´ì¦ˆ)
                for (let i = 0; i < 8; i++) {
                    setTimeout(() => {
                        const bufferSize = 2 * audioContext.sampleRate;
                        const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                        const output = noiseBuffer.getChannelData(0);
                        for (let j = 0; j < bufferSize; j++) {
                            output[j] = Math.random() * 2 - 1;
                        }
                        const whiteNoise = audioContext.createBufferSource();
                        whiteNoise.buffer = noiseBuffer;

                        const gainNode = audioContext.createGain();
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'highpass';
                        filter.frequency.value = 1000;

                        whiteNoise.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

                        whiteNoise.start(audioContext.currentTime);
                        whiteNoise.stop(audioContext.currentTime + 0.1);
                    }, i * 50);
                }
            } catch (e) {
                console.log('Shuffle sound error');
            }
        }

        function playCardPlaySound() {
            // ì°©! (ë” ì§§ê³  ê°„ê²°í•˜ê²Œ)
            try {
                const t = audioContext.currentTime;

                // 1. íƒ€ê²©ê° (Snap) - ì•„ì£¼ ì§§ê²Œ
                const osc = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                osc.connect(oscGain);
                oscGain.connect(audioContext.destination);

                osc.frequency.setValueAtTime(800, t); // ì‹œì‘ ì£¼íŒŒìˆ˜ ë†’ì„ (ë‚ ì¹´ë¡­ê²Œ)
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.05); // ë¹ ë¥´ê²Œ ë–¨ì–´ì§

                oscGain.gain.setValueAtTime(0.8, t);
                oscGain.gain.exponentialRampToValueAtTime(0.01, t + 0.05); // 0.05ì´ˆ ë§Œì— ì‚¬ë¼ì§

                osc.start(t);
                osc.stop(t + 0.05);

                // 2. ë§ˆì°°ìŒ (Click/Clack)
                const bufferSize = audioContext.sampleRate * 0.05; // 0.05ì´ˆ
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;
                const noiseFilter = audioContext.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 2000; // ê³ ìŒì—­ëŒ€ë§Œ ì‚¬ìš©

                const noiseGain = audioContext.createGain();
                noiseGain.gain.setValueAtTime(0.5, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.03);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(audioContext.destination);

                noise.start(t);
            } catch (e) { }
        }

        function playCardDrawSound() {
            // ìŠ¤ìœ½ (ì¢…ì´ ë„˜ê¸°ëŠ” ì†Œë¦¬)
            try {
                const t = audioContext.currentTime;
                const duration = 0.15; // ì•½ê°„ ë” ì§§ê²Œ

                const bufferSize = audioContext.sampleRate * duration;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }

                const noise = audioContext.createBufferSource();
                noise.buffer = buffer;

                // Bandpassë¡œ ì¢…ì´ íŠ¹ìœ ì˜ 'ì‚¬ê°' ì†Œë¦¬ êµ¬í˜„
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.Q.value = 1;
                filter.frequency.setValueAtTime(1000, t);
                filter.frequency.linearRampToValueAtTime(2500, t + duration); // ì£¼íŒŒìˆ˜ ìŠ¤ìœ•

                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, t);
                gainNode.gain.linearRampToValueAtTime(0.5, t + 0.02); // ë¹ ë¥¸ ì–´íƒ
                gainNode.gain.linearRampToValueAtTime(0, t + duration); // í˜ì´ë“œ ì•„ì›ƒ

                noise.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(audioContext.destination);

                noise.start(t);
            } catch (e) { }
        }

        function playSuitChangeSound() {
            // ë ë¦¬ë§~ (ë¬¸ì–‘ ë³€ê²½ - ì•„ë¥´í˜ì§€ì˜¤ íš¨ê³¼)
            try {
                const now = audioContext.currentTime;
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C E G C (ë„ë¯¸ì†”ë„)

                notes.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.connect(gain);
                    gain.connect(audioContext.destination);

                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(freq, now + i * 0.1);

                    gain.gain.setValueAtTime(0, now + i * 0.1);
                    gain.gain.linearRampToValueAtTime(0.1, now + i * 0.1 + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.3);

                    osc.start(now + i * 0.1);
                    osc.stop(now + i * 0.1 + 0.3);
                });
            } catch (e) { }
        }

        function playGameOverSound() {
            try {
                // ìŠ¬í”ˆ í•˜ê°• ë©œë¡œë””
                const notes = [440, 392, 349, 293]; // A4, G4, F4, D4
                notes.forEach((freq, i) => {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.type = 'sine';
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.4);
                    }, i * 300);
                });
            } catch (e) {
                console.log('Game over sound not available');
            }
        }

        // ì‹±ê¸€ í”Œë ˆì´ì–´ ìƒíƒœ
        let isSinglePlayer = false;
        let singlePlayerState = {
            deck: [],
            discardPile: [],
            currentPlayerIndex: 0,
            direction: 1,
            attackStack: 0,
            attackType: null,
            currentSuit: null,
            skipTurns: 0
        };
        const BANKRUPT_LIMIT = 15;
        const AI_NAMES = ['ğŸ¤– AI-1', 'ğŸ¦¾ AI-2', 'ğŸ”§ AI-3', 'âš™ï¸ AI-4', 'ğŸ› ï¸ AI-5'];

        const suitSymbols = {
            'spade': 'â™ ', 'heart': 'â™¥', 'diamond': 'â™¦', 'club': 'â™£'
        };

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
        function generateRoomCode() {
            // 4ìë¦¬ ìˆ«ì ìƒì„±
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        function generatePlayerId() {
            return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // ì‹±ê¸€ í”Œë ˆì´ì–´ í•¨ìˆ˜
        function showSinglePlayerForm() {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('single-player-form').classList.remove('hidden');
        }

        function hideSinglePlayerForm() {
            document.getElementById('single-player-form').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
        }

        function startSinglePlayer() {
            myNickname = document.getElementById('nickname-input').value.trim() || 'í”Œë ˆì´ì–´';
            const aiCount = parseInt(document.getElementById('ai-count-select').value);

            isSinglePlayer = true;
            myPlayerId = 'human';

            // í”Œë ˆì´ì–´ ë°°ì—´ ìƒì„±
            players = [{
                id: 'human',
                name: 'ğŸ‘¤ ' + myNickname,
                hand: [],
                isMe: true,
                isHuman: true,
                isBankrupt: false,
                rank: null,
                slot: 'bottom'
            }];

            // AI í”Œë ˆì´ì–´ ì¶”ê°€
            const totalPlayers = aiCount + 1;
            const slots = {
                2: ['bottom', 'top'],
                3: ['bottom', 'left', 'top'],
                4: ['bottom', 'left', 'top', 'right'],
                5: ['bottom', 'left', 'top-left', 'top-right', 'right'],
                6: ['bottom', 'left', 'top-left', 'top', 'top-right', 'right']
            };

            for (let i = 0; i < aiCount; i++) {
                players.push({
                    id: 'ai_' + i,
                    name: AI_NAMES[i],
                    hand: [],
                    isMe: false,
                    isHuman: false,
                    isBankrupt: false,
                    rank: null,
                    slot: slots[totalPlayers][i + 1]
                });
            }

            // ë± ìƒì„± ë° ì…”í”Œ
            singlePlayerState.deck = createDeck();
            shuffle(singlePlayerState.deck);
            playShuffleSound(); // ì…”í”Œ ì‚¬ìš´ë“œ ì¬ìƒ

            // ì¹´ë“œ ë¶„ë°° (5ì¥ì”©)
            players.forEach(p => {
                p.hand = [];
                for (let i = 0; i < 5; i++) {
                    p.hand.push(singlePlayerState.deck.pop());
                }
            });

            // ì²« ì¹´ë“œ
            let firstCard;
            do {
                firstCard = singlePlayerState.deck.pop();
                if (isSpecialCard(firstCard)) {
                    singlePlayerState.deck.unshift(firstCard);
                } else {
                    break;
                }
            } while (true);

            singlePlayerState.discardPile = [firstCard];
            singlePlayerState.currentSuit = firstCard.suit;
            singlePlayerState.currentPlayerIndex = 0;
            singlePlayerState.direction = 1;
            singlePlayerState.attackStack = 0;
            singlePlayerState.attackType = null;
            singlePlayerState.skipTurns = 0;

            // gameState ë™ê¸°í™”
            gameState = singlePlayerState;

            showGameScreen();
            renderSingle();
            setMessage('ê²Œì„ ì‹œì‘! ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤.');
        }

        // ë¡œë¹„ í•¨ìˆ˜
        function showJoinForm() {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('join-form').classList.remove('hidden');
        }

        function hideJoinForm() {
            document.getElementById('join-form').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
        }

        function createRoom() {
            myNickname = document.getElementById('nickname-input').value.trim();
            if (!myNickname) {
                alert('ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                return;
            }

            myPlayerId = generatePlayerId();
            currentRoomCode = generateRoomCode();
            isHost = true;

            roomRef = database.ref('rooms/' + currentRoomCode);

            roomRef.set({
                host: myPlayerId,
                status: 'waiting',
                createdAt: Date.now(),
                players: {
                    [myPlayerId]: {
                        name: myNickname,
                        connected: true,
                        joinedAt: Date.now()
                    }
                }
            }).then(() => {
                showWaitingRoom();
                listenToRoom();
                setupDisconnectHandler();
            }).catch(err => {
                alert('ë°© ìƒì„± ì‹¤íŒ¨: ' + err.message);
            });
        }

        function joinRoom() {
            myNickname = document.getElementById('nickname-input').value.trim();
            const roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();

            if (!myNickname) {
                alert('ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                return;
            }
            if (!roomCode || roomCode.length !== 4) {
                alert('ì˜¬ë°”ë¥¸ 4ìë¦¬ ìˆ«ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!');
                return;
            }

            myPlayerId = generatePlayerId();
            currentRoomCode = roomCode;
            roomRef = database.ref('rooms/' + currentRoomCode);

            roomRef.once('value').then(snapshot => {
                if (!snapshot.exists()) {
                    alert('ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë°©ì…ë‹ˆë‹¤!');
                    return;
                }

                const roomData = snapshot.val();
                if (roomData.status !== 'waiting') {
                    alert('ì´ë¯¸ ê²Œì„ì´ ì‹œì‘ëœ ë°©ì…ë‹ˆë‹¤!');
                    return;
                }

                const playerCount = Object.keys(roomData.players || {}).length;
                if (playerCount >= 6) {
                    alert('ë°©ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤! (ìµœëŒ€ 6ëª…)');
                    return;
                }

                isHost = false;
                roomRef.child('players/' + myPlayerId).set({
                    name: myNickname,
                    connected: true,
                    joinedAt: Date.now()
                }).then(() => {
                    hideJoinForm();
                    showWaitingRoom();
                    listenToRoom();
                    setupDisconnectHandler();
                });
            });
        }

        function showWaitingRoom() {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('join-form').classList.add('hidden');
            document.getElementById('waiting-room').classList.remove('hidden');
            document.getElementById('room-code-display').textContent = currentRoomCode;

            if (isHost) {
                document.getElementById('host-controls').classList.remove('hidden');
            }
        }

        function setupDisconnectHandler() {
            // ì—°ê²° ëŠê¹€ ì‹œ ì˜¤í”„ë¼ì¸ í‘œì‹œ
            roomRef.child('players/' + myPlayerId + '/connected').onDisconnect().set(false);

            // í™”ë©´ ë³µê·€ ì‹œ ìë™ ì¬ì—°ê²°
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && roomRef && myPlayerId) {
                    roomRef.child('players/' + myPlayerId + '/connected').set(true);
                }
            });

            // í¬ì»¤ìŠ¤ ë³µê·€ ì‹œì—ë„ ì¬ì—°ê²° (ì¼ë¶€ ëª¨ë°”ì¼ ë¸Œë¼ìš°ì €ìš©)
            window.addEventListener('focus', () => {
                if (roomRef && myPlayerId) {
                    roomRef.child('players/' + myPlayerId + '/connected').set(true);
                }
            });
        }

        function listenToRoom() {
            roomRef.on('value', snapshot => {
                if (!snapshot.exists()) {
                    alert('ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!');
                    location.reload();
                    return;
                }

                const roomData = snapshot.val();

                // ê²Œì„ ì‹œì‘ í™•ì¸
                if ((roomData.status === 'playing' || roomData.status === 'finished') && roomData.gameState) {
                    gameState = roomData.gameState;
                    players = [];
                    const playerOrder = roomData.gameState.playerOrder || [];

                    // ë‚´ ìœ„ì¹˜(ì¸ë±ìŠ¤) ë¨¼ì € ì°¾ê¸°
                    const myIndex = playerOrder.indexOf(myPlayerId);

                    playerOrder.forEach((pid, idx) => {
                        const pData = roomData.players[pid];
                        const handData = roomData.gameState.hands ? roomData.gameState.hands[pid] : [];
                        players.push({
                            id: pid,
                            name: pData.name,
                            hand: handData || [],
                            isMe: pid === myPlayerId,
                            isBankrupt: pData.isBankrupt || false,
                            rank: pData.rank || null,
                            slot: getSlotForPlayer(idx, playerOrder.length, myIndex)
                        });
                    });
                    showGameScreen();
                    render();

                    // ì „ì—­ ì•Œë¦¼ í‘œì‹œ (ë¬´ëŠ¬ ë³€ê²½ ë“±)
                    if (gameState.lastAction && gameState.lastActionId && gameState.lastActionId !== window.lastActionIdProcessed) {
                        if (typeof showNotification === 'function') {
                            showNotification(gameState.lastAction);
                        }
                        window.lastActionIdProcessed = gameState.lastActionId;
                    }

                    // ê²Œì„ ì¢…ë£Œ í™•ì¸
                    if (roomData.gameState.status === 'finished' && roomData.gameState.winner) {
                        showGameResult(roomData.gameState.winner, roomData.players);
                    }
                    return;
                }

                // ëŒ€ê¸°ì‹¤ í”Œë ˆì´ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸
                updatePlayerList(roomData);
            });
        }

        function updatePlayerList(roomData) {
            const playerListEl = document.getElementById('player-list');
            const playersData = roomData.players || {};
            const hostId = roomData.host;

            let html = '';
            let connectedCount = 0;

            Object.entries(playersData).forEach(([pid, pData]) => {
                const isMe = pid === myPlayerId;
                const isHostPlayer = pid === hostId;
                const isConnected = pData.connected;

                if (isConnected) connectedCount++;

                html += `
                    <div class="player-item ${isHostPlayer ? 'host' : ''} ${isMe ? 'me' : ''}">
                        <span>${pData.name} ${isMe ? '(ë‚˜)' : ''}</span>
                        <div class="connection-status ${isConnected ? '' : 'offline'}"></div>
                    </div>
                `;
            });

            playerListEl.innerHTML = html;

            // ì‹œì‘ ë²„íŠ¼ í™œì„±í™”
            const startBtn = document.getElementById('start-game-btn');
            if (startBtn) {
                if (connectedCount >= 2) {
                    startBtn.disabled = false;
                    startBtn.textContent = `ğŸ® ê²Œì„ ì‹œì‘ (${connectedCount}ëª…)`;
                } else {
                    startBtn.disabled = true;
                    startBtn.textContent = 'ğŸ® ê²Œì„ ì‹œì‘ (ìµœì†Œ 2ëª… í•„ìš”)';
                }
            }
        }

        function getSlotForPlayer(index, totalPlayers, myIndex) {
            // myIndexê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
            if (myIndex < 0) myIndex = 0;
            const relativeIndex = (index - myIndex + totalPlayers) % totalPlayers;

            const slots = {
                2: ['bottom', 'top'],
                3: ['bottom', 'left', 'top'],
                4: ['bottom', 'left', 'top', 'right'],
                5: ['bottom', 'left', 'top-left', 'top-right', 'right'],
                6: ['bottom', 'left', 'top-left', 'top', 'top-right', 'right']
            };

            return slots[totalPlayers] ? slots[totalPlayers][relativeIndex] : 'bottom';
        }

        function leaveRoom() {
            if (roomRef) {
                roomRef.child('players/' + myPlayerId).remove();
                roomRef.off();
            }
            location.reload();
        }

        // ê²Œì„ ì‹œì‘ (ë°©ì¥ë§Œ)
        function startOnlineGame() {
            if (!isHost) return;

            roomRef.once('value').then(snapshot => {
                const roomData = snapshot.val();
                const playerIds = Object.keys(roomData.players).filter(pid => roomData.players[pid].connected);

                if (playerIds.length < 2) {
                    alert('ìµœì†Œ 2ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤!');
                    return;
                }

                // ë± ìƒì„± ë° ì…”í”Œ
                const deck = createDeck();
                shuffle(deck);
                playShuffleSound(); // ì…”í”Œ ì‚¬ìš´ë“œ ì¬ìƒ

                // ì¹´ë“œ ë¶„ë°° (5ì¥ì”©)
                const hands = {};
                playerIds.forEach(pid => {
                    hands[pid] = [];
                    for (let i = 0; i < 5; i++) {
                        hands[pid].push(deck.pop());
                    }
                });

                // ì²« ì¹´ë“œ (íŠ¹ìˆ˜ ì¹´ë“œ ì œì™¸)
                let firstCard;
                do {
                    firstCard = deck.pop();
                    if (isSpecialCard(firstCard)) {
                        deck.unshift(firstCard);
                    } else {
                        break;
                    }
                } while (true);

                // ê²Œì„ ìƒíƒœ ì €ì¥
                roomRef.update({
                    status: 'playing',
                    gameState: {
                        deck: deck,
                        discardPile: [firstCard],
                        currentPlayerIndex: 0,
                        direction: 1,
                        attackStack: 0,
                        attackType: null,
                        currentSuit: firstCard.suit,
                        skipTurns: 0,
                        playerOrder: playerIds,
                        hands: hands
                    }
                });
            });
        }

        function createDeck() {
            const suits = ['spade', 'heart', 'diamond', 'club'];
            const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const deck = [];

            for (let suit of suits) {
                for (let value of values) {
                    deck.push({ suit, value });
                }
            }
            deck.push({ suit: 'black-joker', value: 'JOKER' });
            deck.push({ suit: 'color-joker', value: 'JOKER' });

            return deck;
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function isSpecialCard(card) {
            return card.value === '2' || card.value === 'A' ||
                card.value === 'J' || card.value === 'Q' || card.value === 'K' ||
                card.suit === 'black-joker' || card.suit === 'color-joker';
        }

        function showGameScreen() {
            document.getElementById('lobby-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
        }

        // ê²Œì„ ë Œë”ë§
        function render() {
            if (!gameState) return;

            document.getElementById('direction').textContent = gameState.direction === 1 ? 'âŸ³ ì‹œê³„' : 'âŸ² ë°˜ì‹œê³„';
            document.getElementById('deck-count').textContent = `ë‚¨ì€ ì¹´ë“œ ìˆ˜: ${gameState.deck.length}`;

            // ìŠ¬ë¡¯ ì´ˆê¸°í™”
            ['top', 'left', 'right', 'bottom', 'top-left', 'top-right'].forEach(slot => {
                const el = document.getElementById('slot-' + slot);
                if (el) el.innerHTML = '';
            });

            // í˜„ì¬ í„´ í”Œë ˆì´ì–´
            const currentPlayer = players[gameState.currentPlayerIndex];
            const isMyTurn = currentPlayer && currentPlayer.isMe;

            document.getElementById('turn-text').textContent = currentPlayer ?
                `${currentPlayer.name}ì˜ í„´` : '';

            // í”Œë ˆì´ì–´ ë Œë”ë§
            players.forEach((p, idx) => {
                const slotEl = document.getElementById('slot-' + p.slot);
                if (!slotEl) return;

                const isCurrent = gameState.currentPlayerIndex === idx;

                if (p.isMe) {
                    // ë‚´ ì¹´ë“œ (ì•ë©´) - ë¼ë²¨ì„ ë…¹ìƒ‰ í…Œë‘ë¦¬ ë°–ìœ¼ë¡œ ì´ë™
                    slotEl.innerHTML = `
                        <div class="player-area ${isCurrent ? 'current-turn' : ''}">
                            <div class="cards-row" style="${p.hand.length > 7 ? 'flex-wrap:wrap;justify-content:center;height:auto;' : ''}">
                                ${p.hand.map((card, i) => {
                        const playable = isMyTurn && canPlayCard(card);
                        const selected = selectedCards.includes(i);
                        const isNormalSuit = ['spade', 'heart', 'diamond', 'club'].includes(card.suit);
                        const valueClass = isNormalSuit ? `val-${card.value}` : '';
                        return `
                                        <div class="card ${card.suit} ${valueClass} ${playable ? 'playable' : ''} ${selected ? 'selected' : ''}"
                                             onclick="toggleCardSelection(${i})"
                                             style="${p.hand.length > 7 ? 'margin-bottom:-40px;' : ''}">
                                        </div>
                                    `;
                    }).join('')}
                            </div>
                        </div>
                        <div class="player-label" style="margin-top:15px;text-align:center;">
                            ${p.name} (ë‚˜)
                            <span class="card-count">${p.hand.length}ì¥</span>
                        </div>
                    `;
                } else {
                    // ìƒëŒ€ ì¹´ë“œ (ë’·ë©´)
                    slotEl.innerHTML = `
                        <div class="player-area opponent-area ${isCurrent ? 'current-turn' : ''}">
                            <div class="player-label">
                                ${p.name}
                                <span class="card-count">${p.hand.length}ì¥</span>
                            </div>
                            <div class="cards-row">
                                ${p.hand.map(() => `<div class="card card-back opponent-card"></div>`).join('')}
                            </div>
                        </div>
                    `;
                }
            });

            // ë²„ë¦° ì¹´ë“œ í‘œì‹œ (ìµœê·¼ 3ì¥ë§Œ)
            const discardEl = document.getElementById('discard-cards');
            const discardCards = gameState.discardPile.slice(-3);
            discardEl.innerHTML = discardCards.map((card, i) => {
                const isTop = i === discardCards.length - 1;

                let valueClass = `val-${card.value}`;
                if (card.symbol) valueClass += ` ${card.symbol}`;

                return `
                    <div class="card ${card.suit} ${valueClass}"
                         style="width:60px;height:85px;margin-left:${i === 0 ? 0 : -45}px;position:relative;z-index:${i + 10};box-shadow:-2px 0 5px rgba(0,0,0,0.3);">
                    </div>
                `;
            }).join('');

            // ë± í•˜ì´ë¼ì´íŠ¸
            const deckEl = document.querySelector('.deck');
            if (deckEl) deckEl.classList.remove('highlight');

            // ë± ì´ë¯¸ì§€ ê°•ì œ ì ìš© (CSS ìš°ì„ ìˆœìœ„ ë¬¸ì œ í•´ê²°)
            const deckCardBack = document.querySelector('.deck .card-back');
            if (deckCardBack) {
                deckCardBack.style.position = 'absolute';
                deckCardBack.style.width = '100%';
                deckCardBack.style.height = '100%';
                deckCardBack.style.background = "url('cards/card_back_custom.jpg?v=1') center/cover no-repeat";
                deckCardBack.style.borderRadius = "8px";
            }

            if (currentPlayer && currentPlayer.isMe) {
                const myHandInfo = players.find(p => p.isMe);
                if (myHandInfo && myHandInfo.hand) {
                    const hasPlayable = myHandInfo.hand.some(card => canPlayCard(card));
                    if (!hasPlayable && deckEl) {
                        deckEl.classList.add('highlight');
                    }
                }
            }

            // ì•¡ì…˜ ë²„íŠ¼
            document.getElementById('action-buttons').style.display = selectedCards.length > 0 ? 'flex' : 'none';

            // ë©”ì‹œì§€
            if (gameState.attackStack > 0 && isMyTurn) {
                setMessage(`âš”ï¸ ${gameState.attackStack}ì¥ ê³µê²©!`, 'attack');
            } else if (isMyTurn) {
                setMessage('ë‹¹ì‹ ì˜ í„´ì…ë‹ˆë‹¤');
            } else {
                const currentP = players[gameState.currentPlayerIndex];
                setMessage(`${currentP ? currentP.name : ''}ì˜ í„´...`);
            }

            // ë‚´ í„´ìœ¼ë¡œ ë°”ë€Œì—ˆì„ ë•Œ ì•Œë¦¼ìŒ ì¬ìƒ
            if (isMyTurn && lastTurnIndex !== gameState.currentPlayerIndex) {
                playTurnSound();
            }
            lastTurnIndex = gameState.currentPlayerIndex;
        }

        function setMessage(text, type = '') {
            const msgBox = document.getElementById('message');
            msgBox.textContent = text;
            msgBox.className = 'message-box' + (type ? ' ' + type : '');
        }

        function showGameResult(winnerId, playersData) {
            const winnerData = playersData[winnerId];
            const winnerName = winnerData ? winnerData.name : 'ìŠ¹ì';
            const isMe = winnerId === myPlayerId;

            // ìŠ¹íŒ¨ ì‚¬ìš´ë“œ ì¬ìƒ
            if (!isMe) {
                playGameOverSound();
            }

            let resultHtml = `
                <div style="text-align:center;margin-bottom:20px;">
                    <h2>ğŸ† ê²Œì„ ì¢…ë£Œ!</h2>
                    <div style="font-size:1.5rem;margin:15px 0;color:#fbbf24;">
                        ${isMe ? 'ğŸ‰ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤ğŸ¥³' : 'íŒ¨ë°°í•˜ì˜€ìŠµë‹ˆë‹¤...ğŸ˜¢'}
                    </div>
                </div>
                <button class="btn btn-primary" style="width:100%;margin-top:15px;" onclick="location.reload()">
                    ğŸ”„ ë‹¤ì‹œ í•˜ê¸°
                </button>
            `;

            document.getElementById('message').innerHTML = resultHtml;
            document.getElementById('message').style.minWidth = '280px';
            document.getElementById('action-buttons').style.display = 'none';
        }

        function canPlayCard(card) {
            const currentPlayer = players[gameState.currentPlayerIndex];
            if (!currentPlayer || !currentPlayer.isMe) return false;

            if (gameState.attackStack > 0) {
                return canDefendWith(card);
            }

            const topCard = gameState.discardPile[gameState.discardPile.length - 1];

            // ì¡°ì»¤ ê³µê²© í”¼í•´ í›„ ì•„ë¬´ ì¹´ë“œë‚˜ ë‚¼ ìˆ˜ ìˆìŒ
            if (gameState.currentSuit === 'any') return true;

            if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
            if (card.suit === gameState.currentSuit) return true;
            if (card.value === topCard.value) return true;

            return false;
        }

        function canDefendWith(card) {
            const attackType = gameState.attackType;
            if (!attackType) return true;

            if (attackType === '2') {
                if (card.value === '2') return true;
                if (card.value === 'A' && card.suit === gameState.currentSuit) return true;
                if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
                return false;
            }
            if (attackType === 'A') {
                if (card.value === 'A') return true;
                if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
                return false;
            }
            if (attackType === 'black-joker') {
                if (card.value === 'A' && card.suit === 'spade') return true;
                if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
                return false;
            }
            if (attackType === 'color-joker') {
                if (card.value === 'A' && card.suit === 'spade') return true;
                if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
                return false;
            }
            return false;
        }

        function toggleCardSelection(index) {
            const currentPlayer = players[gameState.currentPlayerIndex];
            if (!currentPlayer || !currentPlayer.isMe) return;

            const card = currentPlayer.hand[index];

            const idx = selectedCards.indexOf(index);
            if (idx > -1) {
                // ì´ë¯¸ ì„ íƒëœ ì¹´ë“œ í•´ì œ
                selectedCards.splice(idx, 1);
            } else {
                if (selectedCards.length > 0) {
                    // ì´ë¯¸ ì„ íƒëœ ì¹´ë“œê°€ ìˆìœ¼ë©´ ê°™ì€ ìˆ«ìë§Œ í—ˆìš©
                    const firstCard = currentPlayer.hand[selectedCards[0]];
                    if (card.value !== firstCard.value) {
                        alert('ê°™ì€ ìˆ«ìì˜ ì¹´ë“œë§Œ í•¨ê»˜ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤!');
                        return;
                    }
                    selectedCards.push(index);
                } else {
                    // ì²« ë²ˆì§¸ ì¹´ë“œëŠ” í”Œë ˆì´ ê°€ëŠ¥í•´ì•¼ í•¨
                    if (!canPlayCard(card)) return;
                    selectedCards.push(index);
                }
            }
            render();
        }

        function clearSelection() {
            selectedCards = [];
            if (isSinglePlayer) {
                renderSingle();
            } else {
                render();
            }
        }

        // ì˜¨ë¼ì¸ ë¬´ëŠ¬ ì„ íƒ

        function selectSuitOnline(suit) {
            document.getElementById('suit-selector').style.display = 'none';

            if (window.pendingUpdate) {
                const { newHand, newDiscardPile, newDeck, newAttackStack, newAttackType,
                    newSkipTurns, newDirection, nextPlayerIndex } = window.pendingUpdate;

                updateGameState({
                    deck: newDeck,
                    discardPile: newDiscardPile,
                    currentPlayerIndex: nextPlayerIndex,
                    direction: newDirection,
                    attackStack: newAttackStack,
                    attackType: newAttackType,
                    currentSuit: suit,
                    skipTurns: 0,
                    [`hands/${myPlayerId}`]: newHand
                });

                window.pendingUpdate = null;
            }
        }

        function drawCardOnline() {
            const currentPlayer = players[gameState.currentPlayerIndex];
            if (!currentPlayer || !currentPlayer.isMe) {
                alert('ë‹¹ì‹ ì˜ í„´ì´ ì•„ë‹™ë‹ˆë‹¤!');
                return;
            }

            const myPlayer = players.find(p => p.isMe);
            if (!myPlayer) return;

            const cardsToDraw = gameState.attackStack > 0 ? gameState.attackStack : 1;
            const newDeck = [...gameState.deck];
            const newHand = [...myPlayer.hand];

            for (let i = 0; i < cardsToDraw; i++) {
                if (newDeck.length === 0) {
                    // ë± ë¦¬ì…”í”Œ
                    const topCard = gameState.discardPile[gameState.discardPile.length - 1];
                    const reshuffled = gameState.discardPile.slice(0, -1);
                    shuffle(reshuffled);
                    newDeck.push(...reshuffled);
                }
                if (newDeck.length > 0) {
                    newHand.push(newDeck.pop());
                    playCardDrawSound(); // ì†Œë¦¬ ì¶”ê°€ (ì˜¨ë¼ì¸)
                }
            }

            // ë‹¤ìŒ í„´
            let nextPlayerIndex = (gameState.currentPlayerIndex + gameState.direction + players.length) % players.length;

            // ì¡°ì»¤ ê³µê²© í›„ ì¹´ë“œ ë¨¹ìœ¼ë©´ ì•„ë¬´ ì¹´ë“œë‚˜ ë‚¼ ìˆ˜ ìˆìŒ
            const wasJokerAttack = gameState.attackType === 'black-joker' || gameState.attackType === 'color-joker';

            // íŒŒì‚° ì²´í¬ (15ì¥ ì´ˆê³¼)
            const nextSuit = wasJokerAttack ? 'any' : gameState.currentSuit;
            let isBankrupt = false;
            let rank = null;
            let winner = null;

            if (newHand.length > 15) {
                isBankrupt = true;
                const activePlayers = players.filter(p => !p.isBankrupt && p.rank === null);
                rank = activePlayers.length;
                if (activePlayers.length - 1 === 1) {
                    const survivor = activePlayers.find(p => p.id !== myPlayerId);
                    if (survivor) winner = survivor.id;
                }
                alert('ì¹´ë“œê°€ 15ì¥ì„ ì´ˆê³¼í•˜ì—¬ íŒŒì‚°í–ˆìŠµë‹ˆë‹¤! ğŸ˜±');
            }

            const updates = {
                deck: newDeck,
                currentPlayerIndex: nextPlayerIndex,
                attackStack: 0,
                attackType: null,
                currentSuit: nextSuit,
                skipTurns: 0,
                [`hands/${myPlayerId}`]: newHand
            };

            if (isBankrupt) {
                updates[`players/${myPlayerId}/isBankrupt`] = true;
                updates[`players/${myPlayerId}/rank`] = rank;
            }
            if (winner) {
                updates.status = 'finished';
                updates.winner = winner;
            }

            updateGameState(updates);
        }

        function updateGameState(updates) {
            const gameStateRef = roomRef.child('gameState');
            gameStateRef.update(updates);
        }

        // ==================== ì‹±ê¸€ í”Œë ˆì´ì–´ ì „ìš© í•¨ìˆ˜ë“¤ ====================

        function renderSingle() {
            if (!isSinglePlayer) return render();

            document.getElementById('direction').textContent = singlePlayerState.direction === 1 ? 'âŸ³ ì‹œê³„' : 'âŸ² ë°˜ì‹œê³„';
            document.getElementById('deck-count').textContent = `ë‚¨ì€ ì¹´ë“œ ìˆ˜: ${singlePlayerState.deck.length}`;

            // ìŠ¬ë¡¯ ì´ˆê¸°í™”
            ['top', 'left', 'right', 'bottom', 'top-left', 'top-right'].forEach(slot => {
                const el = document.getElementById('slot-' + slot);
                if (el) el.innerHTML = '';
            });

            const currentPlayer = players[singlePlayerState.currentPlayerIndex];
            document.getElementById('turn-text').textContent = currentPlayer ? `${currentPlayer.name}ì˜ í„´` : '';

            // í”Œë ˆì´ì–´ ë Œë”ë§
            players.forEach((p, idx) => {
                const slotEl = document.getElementById('slot-' + p.slot);
                if (!slotEl) return;

                const isCurrent = singlePlayerState.currentPlayerIndex === idx;

                if (p.isHuman) {
                    // ë‚´ ì¹´ë“œ (ì•ë©´) - ë¼ë²¨ì„ ë…¹ìƒ‰ í…Œë‘ë¦¬ ë°–ìœ¼ë¡œ ì´ë™
                    slotEl.innerHTML = `
                        <div class="player-area ${isCurrent ? 'current-turn' : ''} ${p.isBankrupt ? 'bankrupt' : ''}">
                            <div class="cards-row">
                                ${p.rank ? '' : p.hand.map((card, i) => {
                        const playable = isCurrent && canPlayCardSingle(card);
                        const selected = selectedCards.includes(i);
                        const isNormalSuit = ['spade', 'heart', 'diamond', 'club'].includes(card.suit);
                        const valueClass = isNormalSuit ? `val-${card.value}` : '';
                        return `
                                        <div class="card ${card.suit} ${valueClass} ${playable ? 'playable' : ''} ${selected ? 'selected' : ''}"
                                             onclick="toggleCardSelectionSingle(${i})">
                                        </div>
                                    `;
                    }).join('')}
                            </div>
                        </div>
                        <div class="player-label" style="margin-top:15px;text-align:center;">
                            ${p.name}
                            <span class="card-count">${p.hand.length}ì¥</span>
                            ${p.isBankrupt ? '<span style="background:#ef4444;padding:2px 6px;border-radius:5px;font-size:0.8rem;">íŒŒì‚°</span>' : ''}
                            ${p.rank ? `<span style="background:#4ade80;padding:2px 6px;border-radius:5px;font-size:0.8rem;">${p.rank}ë“±</span>` : ''}
                        </div>
                    `;
                } else {
                    // AI ì¹´ë“œ (ë’·ë©´)
                    slotEl.innerHTML = `
                        <div class="player-area opponent-area ${isCurrent ? 'current-turn' : ''} ${p.isBankrupt ? 'bankrupt' : ''}">
                            <div class="player-label">
                                ${p.name}
                                <span class="card-count">${p.hand.length}ì¥</span>
                                ${p.isBankrupt ? '<span style="background:#ef4444;padding:2px 6px;border-radius:5px;font-size:0.8rem;">íŒŒì‚°</span>' : ''}
                                ${p.rank ? `<span style="background:#4ade80;padding:2px 6px;border-radius:5px;font-size:0.8rem;">${p.rank}ë“±</span>` : ''}
                            </div>
                            <div class="cards-row">
                                ${p.rank ? '' : p.hand.map(() => `<div class="card card-back opponent-card"></div>`).join('')}
                            </div>
                            </div>
                        </div>
                    `;
                }
            });

            // ë²„ë¦° ì¹´ë“œ ë”ë¯¸
            const discardEl = document.getElementById('discard-cards');
            const topCards = singlePlayerState.discardPile.slice(-3);
            discardEl.innerHTML = topCards.map((card, idx) => {
                const isTop = idx === topCards.length - 1;
                const isNormalSuit = ['spade', 'heart', 'diamond', 'club'].includes(card.suit);
                const valueClass = isNormalSuit ? `val-${card.value}` : '';
                const opacity = isTop ? '1' : (idx === topCards.length - 2 ? '0.7' : '0.4');
                return `
                    <div class="card ${card.suit} ${valueClass}"
                         style="width:${isTop ? 60 : 45}px;height:${isTop ? 85 : 65}px;opacity:${opacity};cursor:default;position:relative;z-index:${idx + 10};">
                    </div>
                `;
            }).join('');

            document.getElementById('action-buttons').style.display = selectedCards.length > 0 ? 'flex' : 'none';

            // ë‚¼ ì¹´ë“œê°€ ì—†ìœ¼ë©´ ë± í•˜ì´ë¼ì´íŠ¸
            const deckEl = document.querySelector('.deck');
            if (deckEl) deckEl.classList.remove('highlight');

            const currentP = players[singlePlayerState.currentPlayerIndex];
            if (currentP && currentP.isHuman) {
                const hasPlayable = currentP.hand.some(card => canPlayCardSingle(card));
                if (!hasPlayable && deckEl) {
                    deckEl.classList.add('highlight');
                }
            }
        }

        function canPlayCardSingle(card) {
            if (singlePlayerState.attackStack > 0) {
                return canDefendWithSingle(card);
            }
            const topCard = singlePlayerState.discardPile[singlePlayerState.discardPile.length - 1];

            // ì¡°ì»¤ ê³µê²© í”¼í•´ í›„ ì•„ë¬´ ì¹´ë“œë‚˜ ë‚¼ ìˆ˜ ìˆìŒ
            if (singlePlayerState.currentSuit === 'any') return true;

            if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
            if (card.suit === singlePlayerState.currentSuit) return true;
            if (card.value === topCard.value) return true;
            return false;
        }

        function canDefendWithSingle(card) {
            const attackType = singlePlayerState.attackType;
            if (!attackType) return true;

            if (attackType === '2') {
                if (card.value === '2') return true;
                if (card.value === 'A' && card.suit === singlePlayerState.currentSuit) return true;
                if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
                return false;
            }
            if (attackType === 'A') {
                if (card.value === 'A') return true;
                if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
                return false;
            }
            if (attackType === 'black-joker' || attackType === 'color-joker') {
                if (card.value === 'A' && card.suit === 'spade') return true;
                if (card.suit === 'black-joker' || card.suit === 'color-joker') return true;
                return false;
            }
            return false;
        }

        function toggleCardSelectionSingle(index) {
            const currentPlayer = players[singlePlayerState.currentPlayerIndex];
            if (!currentPlayer || !currentPlayer.isHuman) return;

            const card = currentPlayer.hand[index];

            const idx = selectedCards.indexOf(index);
            if (idx > -1) {
                // ì´ë¯¸ ì„ íƒëœ ì¹´ë“œ í•´ì œ
                selectedCards.splice(idx, 1);
            } else {
                if (selectedCards.length > 0) {
                    // ì´ë¯¸ ì„ íƒëœ ì¹´ë“œê°€ ìˆìœ¼ë©´ ê°™ì€ ìˆ«ìë§Œ í—ˆìš©
                    const firstCard = currentPlayer.hand[selectedCards[0]];
                    if (card.value !== firstCard.value) {
                        alert('ê°™ì€ ìˆ«ìì˜ ì¹´ë“œë§Œ í•¨ê»˜ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤!');
                        return;
                    }
                    selectedCards.push(index);
                } else {
                    // ì²« ë²ˆì§¸ ì¹´ë“œëŠ” í”Œë ˆì´ ê°€ëŠ¥í•´ì•¼ í•¨
                    if (!canPlayCardSingle(card)) return;
                    selectedCards.push(index);
                }
            }
            renderSingle();
        }

        function playSelectedCardsOnline() {
            if (isSinglePlayer) {
                playSelectedCardsSingle();
            } else {
                playSelectedCardsOnlineOriginal();
            }
        }

        function playSelectedCardsSingle() {
            if (selectedCards.length === 0) return;

            const player = players.find(p => p.isHuman);
            const cards = selectedCards.map(i => player.hand[i]);

            selectedCards.sort((a, b) => b - a).forEach(i => player.hand.splice(i, 1));
            cards.forEach(card => singlePlayerState.discardPile.push(card));
            playCardPlaySound(); // ì†Œë¦¬ ì¶”ê°€ (ì‹±ê¸€ ë‚´ë¶€)

            const lastCard = cards[cards.length - 1];
            if (lastCard.suit !== 'black-joker' && lastCard.suit !== 'color-joker') {
                singlePlayerState.currentSuit = lastCard.suit;
            }

            handleSpecialCardsSingle(cards);
            selectedCards = [];

            if (player.hand.length === 0) {
                const currentRank = players.filter(p => p.rank !== null).length + 1;
                player.rank = currentRank;
                setMessage(`ğŸ‰ ${player.name}ë‹˜ì´ ${currentRank}ë“±ìœ¼ë¡œ íƒˆì¶œ!`);
                renderSingle();
                if (isGameOverSingle()) {
                    setTimeout(endGameSingle, 1500);
                } else {
                    setTimeout(nextTurnSingle, 1500);
                }
                return;
            }

            if (cards[0].value === '7' && cards[0].suit !== 'black-joker' && cards[0].suit !== 'color-joker') {
                document.getElementById('suit-selector').style.display = 'flex';
                return;
            }

            nextTurnSingle();
        }

        function handleSpecialCardsSingle(cards) {
            const value = cards[0].value;
            const count = cards.length;

            // ì¡°ì»¤ ê°ì§€ (ì˜¨ë¼ì¸ê³¼ ë™ì¼í•˜ê²Œ some() ì‚¬ìš©)
            const hasBlackJoker = cards.some(c => c.suit === 'black-joker');
            const hasColorJoker = cards.some(c => c.suit === 'color-joker');

            if (value === '2') {
                singlePlayerState.attackStack += 2 * count;
                singlePlayerState.attackType = '2';
                setMessage(`âš”ï¸ +${2 * count}ì¥! (ëˆ„ì : ${singlePlayerState.attackStack}ì¥)`, 'attack');
            } else if (value === 'A') {
                singlePlayerState.attackStack += 3 * count;
                singlePlayerState.attackType = 'A';
                setMessage(`âš”ï¸ +${3 * count}ì¥! (ëˆ„ì : ${singlePlayerState.attackStack}ì¥)`, 'attack');
            } else if (hasBlackJoker) {
                singlePlayerState.attackStack += 5 * count;
                singlePlayerState.attackType = 'black-joker';
                setMessage(`ğŸ–¤ +${5 * count}ì¥!`, 'attack');
            } else if (hasColorJoker) {
                singlePlayerState.attackStack += 7 * count;
                singlePlayerState.attackType = 'color-joker';
                setMessage(`ğŸŒˆ +${7 * count}ì¥!`, 'attack');
            } else if (value === 'K') {
                const activeCount = players.filter(p => !p.isBankrupt && p.rank === null).length;
                let kSkips = 0;

                if (activeCount <= 2) {
                    // 2ì¸: ì§ìˆ˜ ì¥(ë‚´ í„´), í™€ìˆ˜ ì¥(ìƒëŒ€ í„´)
                    kSkips = (count * 2);
                    if (count % 2 === 0) kSkips -= 1;
                } else {
                    // 3ì¸ ì´ìƒ: 1ì¥ë‹¹ 3ì¹¸ ì´ë™ (2ëª… ê±´ë„ˆë›°ê¸°)
                    // ê¸°ë³¸ 1ì¹¸ + ìŠ¤í‚µ (count*3 - 1)
                    kSkips = (count * 3) - 1;
                }

                singlePlayerState.skipTurns += kSkips;
                singlePlayerState.attackStack = 0;
                singlePlayerState.attackType = null;
                setMessage(`ğŸ‘‘ ${kSkips}í„´ ìŠ¤í‚µ!`);
            } else if (value === 'Q') {
                const activeCount = players.filter(p => !p.isBankrupt && p.rank === null).length;
                if (activeCount <= 2) {
                    singlePlayerState.skipTurns += 1 * count;
                    setMessage(`ğŸ‘¸ ${count}í„´ ìŠ¤í‚µ!`);
                } else if (count % 2 === 1) {
                    singlePlayerState.direction *= -1;
                    setMessage(`ğŸ‘¸ ë°©í–¥ ì „í™˜! ${singlePlayerState.direction === 1 ? 'âŸ³' : 'âŸ²'}`);
                }
                singlePlayerState.attackStack = 0;
                singlePlayerState.attackType = null;
            } else if (value === 'J') {
                const activeCount = players.filter(p => !p.isBankrupt && p.rank === null).length;
                let jSkips = 0;

                if (activeCount <= 2) {
                    jSkips = count; // 2ì¸ì€ 1ì¥ë‹¹ 1ìŠ¤í‚µ (ê¸°ì¡´ ìœ ì§€)
                } else {
                    // 3ì¸ ì´ìƒ: 1ì¥ë‹¹ 2ì¹¸ ì´ë™ (1ëª… ê±´ë„ˆë›°ê¸°)
                    // ê¸°ë³¸ 1ì¹¸ + ìŠ¤í‚µ (count*2 - 1)
                    jSkips = (count * 2) - 1;
                }

                singlePlayerState.skipTurns += jSkips;
                singlePlayerState.attackStack = 0;
                singlePlayerState.attackType = null;
                setMessage(`ğŸ­ ${jSkips}í„´ ìŠ¤í‚µ!`);
            } else {
                // ì¼ë°˜ ì¹´ë“œë„ ê³µê²© ì´ˆê¸°í™”
                singlePlayerState.attackStack = 0;
                singlePlayerState.attackType = null;
            }
        }

        function selectSuitOnline(suit) {
            if (isSinglePlayer) {
                singlePlayerState.currentSuit = suit;
                document.getElementById('suit-selector').style.display = 'none';

                // ë¬´ëŠ¬ ë³€ê²½ ì•Œë¦¼ íŒì—… (ì˜¨ë¼ì¸ê³¼ ë™ì¼)
                const suitNames = { 'spade': 'â™  ìŠ¤í˜ì´ë“œ', 'heart': 'â™¥ í•˜íŠ¸', 'diamond': 'â™¦ ë‹¤ì´ì•„ëª¬ë“œ', 'club': 'â™£ í´ë¡œë²„' };
                const humanPlayer = players.find(p => p.isHuman);
                const playerName = humanPlayer ? humanPlayer.name : 'í”Œë ˆì´ì–´';
                showNotification(`${playerName}ë‹˜ì´ ë¬¸ì–‘ì„ [${suitNames[suit]}]ë¡œ ë°”ê¿¨ìŠµë‹ˆë‹¤!`);
                playSuitChangeSound(); // ì†Œë¦¬ ì¶”ê°€

                setMessage(`â™»ï¸ ${suitSymbols[suit]} ì„ íƒ!`);

                // 7ì¹´ë“œë¡œ ë§ˆì§€ë§‰ ì¹´ë“œë¥¼ ëƒˆì„ ë•Œ ìŠ¹ë¦¬ ì²´í¬ (ì˜¨ë¼ì¸ê³¼ ë™ì¼)
                if (humanPlayer && humanPlayer.hand.length === 0) {
                    const currentRank = players.filter(p => p.rank !== null).length + 1;
                    humanPlayer.rank = currentRank;
                    setMessage(`ğŸ‰ ${humanPlayer.name}ë‹˜ì´ ${currentRank}ë“±ìœ¼ë¡œ íƒˆì¶œ!`);
                    renderSingle();
                    if (isGameOverSingle()) {
                        setTimeout(endGameSingle, 1500);
                    } else {
                        setTimeout(nextTurnSingle, 1500);
                    }
                    return;
                }

                nextTurnSingle();
            } else {
                selectSuitOnlineOriginal(suit);
            }
        }

        function drawCardOnline() {
            if (isSinglePlayer) {
                drawCardSingle();
            } else {
                drawCardOnlineOriginal();
            }
        }

        function drawCardSingle() {
            const player = players.find(p => p.isHuman);
            if (!player || player.isBankrupt) return;
            if (singlePlayerState.currentPlayerIndex !== players.indexOf(player)) {
                alert('ë‹¹ì‹ ì˜ í„´ì´ ì•„ë‹™ë‹ˆë‹¤!');
                return;
            }
            drawCardsForPlayerSingle(player);
            nextTurnSingle();
        }

        function drawCardsForPlayerSingle(player) {
            const count = singlePlayerState.attackStack > 0 ? singlePlayerState.attackStack : 1;

            for (let i = 0; i < count; i++) {
                if (singlePlayerState.deck.length === 0) reshuffleDeckSingle();
                if (singlePlayerState.deck.length > 0) {
                    player.hand.push(singlePlayerState.deck.pop());
                    if (player.isHuman) playCardDrawSound(); // ì†Œë¦¬ ì¶”ê°€
                }
            }

            if (singlePlayerState.attackStack > 0) {
                // ì¡°ì»¤ ê³µê²© í›„ ì¹´ë“œë¥¼ ë¨¹ìœ¼ë©´ ë‹¤ìŒ ì‚¬ëŒì€ ì•„ë¬´ ì¹´ë“œë‚˜ ë‚¼ ìˆ˜ ìˆìŒ
                const wasJokerAttack = singlePlayerState.attackType === 'black-joker' || singlePlayerState.attackType === 'color-joker';
                if (wasJokerAttack) {
                    singlePlayerState.currentSuit = 'any';
                }
                setMessage(`ğŸ’¥ ${player.name} ${singlePlayerState.attackStack}ì¥ ë½‘ìŒ!`);
                singlePlayerState.attackStack = 0;
                singlePlayerState.attackType = null;
            } else {
                setMessage(`ğŸ“¥ ${player.name} 1ì¥ ë½‘ìŒ`);
            }

            if (player.hand.length > BANKRUPT_LIMIT) {
                player.isBankrupt = true;
                singlePlayerState.deck.push(...player.hand);
                player.hand = [];
                shuffle(singlePlayerState.deck);
                setMessage(`ğŸ’€ ${player.name} íŒŒì‚°!`, 'attack');
            }
        }

        function reshuffleDeckSingle() {
            if (singlePlayerState.discardPile.length <= 1) return;
            const topCard = singlePlayerState.discardPile.pop();
            shuffle(singlePlayerState.discardPile);
            singlePlayerState.deck.push(...singlePlayerState.discardPile);
            singlePlayerState.discardPile = [topCard];
        }

        function isGameOverSingle() {
            const remaining = players.filter(p => !p.isBankrupt && p.rank === null);
            return remaining.length <= 1;
        }

        function nextTurnSingle() {
            const activePlayers = players.filter(p => !p.isBankrupt && p.rank === null);

            if (activePlayers.length <= 1) {
                if (activePlayers.length === 1 && activePlayers[0].rank === null) {
                    const nextRank = players.filter(p => p.rank !== null).length + 1;
                    activePlayers[0].rank = nextRank;
                }
                endGameSingle();
                return;
            }

            // 2ëª… ë‚¨ì•˜ì„ ë•Œ ìŠ¤í‚µ ê°•ì œ ê³ ì • ë¡œì§ ì œê±° (Kì¹´ë“œë³„ ë¡œì§ìœ¼ë¡œ ëŒ€ì²´)

            while (singlePlayerState.skipTurns > 0) {
                singlePlayerState.currentPlayerIndex = (singlePlayerState.currentPlayerIndex + singlePlayerState.direction + players.length) % players.length;
                while (players[singlePlayerState.currentPlayerIndex].isBankrupt || players[singlePlayerState.currentPlayerIndex].rank !== null) {
                    singlePlayerState.currentPlayerIndex = (singlePlayerState.currentPlayerIndex + singlePlayerState.direction + players.length) % players.length;
                }
                singlePlayerState.skipTurns--;
            }

            singlePlayerState.currentPlayerIndex = (singlePlayerState.currentPlayerIndex + singlePlayerState.direction + players.length) % players.length;

            let safety = 0;
            while ((players[singlePlayerState.currentPlayerIndex].isBankrupt || players[singlePlayerState.currentPlayerIndex].rank !== null) && safety < players.length) {
                singlePlayerState.currentPlayerIndex = (singlePlayerState.currentPlayerIndex + singlePlayerState.direction + players.length) % players.length;
                safety++;
            }

            if (isGameOverSingle()) {
                const survivor = players.find(p => !p.isBankrupt && p.rank === null);
                if (survivor) survivor.rank = players.filter(p => p.rank !== null).length + 1;
                endGameSingle();
                return;
            }

            renderSingle();

            const cp = players[singlePlayerState.currentPlayerIndex];
            if (cp.isHuman) {
                // ë‚´ í„´ ì•Œë¦¼ìŒ ì¬ìƒ (ì˜¨ë¼ì¸ê³¼ ë™ì¼)
                playTurnSound();

                if (singlePlayerState.attackStack > 0) {
                    setMessage(`âš”ï¸ ${singlePlayerState.attackStack}ì¥ ê³µê²©! ë°©ì–´ ë˜ëŠ” ë½‘ê¸°`, 'attack');
                } else {
                    setMessage('ë‹¹ì‹ ì˜ í„´');
                }
            } else {
                const delay = 1000 + Math.random() * 2000;
                setTimeout(aiTurnSingle, delay);
            }
        }

        function aiTurnSingle() {
            const player = players[singlePlayerState.currentPlayerIndex];
            if (player.isBankrupt || player.isHuman) return;

            let playable = [];
            for (let i = 0; i < player.hand.length; i++) {
                if (canPlayCardSingle(player.hand[i])) {
                    playable.push({ index: i, card: player.hand[i] });
                }
            }

            if (playable.length === 0) {
                drawCardsForPlayerSingle(player);
                nextTurnSingle();
                return;
            }

            // ê°™ì€ ìˆ«ì ì¹´ë“œ ë¬¶ê¸°
            const groups = {};
            playable.forEach(pc => {
                const val = pc.card.value;
                if (!groups[val]) groups[val] = [];
                groups[val].push(pc);
            });

            let bestGroup = null;
            for (let val in groups) {
                if (!bestGroup || groups[val].length > bestGroup.length) {
                    bestGroup = groups[val];
                }
            }

            const indices = bestGroup.map(pc => pc.index).sort((a, b) => b - a);
            const cards = indices.map(i => player.hand[i]);

            indices.forEach(i => player.hand.splice(i, 1));
            cards.forEach(card => singlePlayerState.discardPile.push(card));
            playCardPlaySound(); // AI ì†Œë¦¬ ì¶”ê°€

            const lastCard = cards[cards.length - 1];
            if (lastCard.suit !== 'black-joker' && lastCard.suit !== 'color-joker') {
                singlePlayerState.currentSuit = lastCard.suit;
            }

            // AIê°€ 7ì„ ëƒˆì„ ë•Œ ë¬´ëŠ¬ ì„ íƒ
            if (lastCard.value === '7') {
                const suitCounts = {};
                player.hand.forEach(c => {
                    if (c.suit !== 'black-joker' && c.suit !== 'color-joker') {
                        suitCounts[c.suit] = (suitCounts[c.suit] || 0) + 1;
                    }
                });
                let best = singlePlayerState.currentSuit, max = 0;
                for (let s in suitCounts) {
                    if (suitCounts[s] > max) { max = suitCounts[s]; best = s; }
                }
                singlePlayerState.currentSuit = best;

                // AI 7ì¹´ë“œ ë¬´ëŠ¬ ë³€ê²½ ì•Œë¦¼ (ì˜¨ë¼ì¸ê³¼ ë™ì¼)
                const suitNames = { 'spade': 'â™  ìŠ¤í˜ì´ë“œ', 'heart': 'â™¥ í•˜íŠ¸', 'diamond': 'â™¦ ë‹¤ì´ì•„ëª¬ë“œ', 'club': 'â™£ í´ë¡œë²„' };
                showNotification(`${player.name}ë‹˜ì´ ë¬¸ì–‘ì„ [${suitNames[best]}]ë¡œ ë°”ê¿¨ìŠµë‹ˆë‹¤!`);
                playSuitChangeSound(); // ì†Œë¦¬ ì¶”ê°€
            }

            handleSpecialCardsSingle(cards);

            if (player.hand.length === 0) {
                const currentRank = players.filter(p => p.rank !== null).length + 1;
                player.rank = currentRank;
                setMessage(`ğŸŠ ${player.name}ë‹˜ì´ ${currentRank}ë“±ìœ¼ë¡œ íƒˆì¶œ!`);
                renderSingle();
                if (isGameOverSingle()) {
                    setTimeout(endGameSingle, 1500);
                } else {
                    setTimeout(nextTurnSingle, 1500);
                }
                return;
            }

            nextTurnSingle();
        }

        function endGameSingle() {
            renderSingle();
            const sortedPlayers = [...players].sort((a, b) => {
                if (a.rank !== null && b.rank !== null) return a.rank - b.rank;
                if (a.rank !== null) return -1;
                if (b.rank !== null) return 1;
                return 0;
            });

            let rankHtml = '<div style="text-align:center;margin-bottom:20px;"><h2>ğŸ† ê²Œì„ ê²°ê³¼</h2></div>';
            rankHtml += '<div style="background:rgba(0,0,0,0.3);padding:15px;border-radius:10px;">';
            sortedPlayers.forEach(p => {
                let status = p.rank ? `${p.rank}ë“±` : (p.isBankrupt ? 'íŒŒì‚°' : 'ì§„í–‰ì¤‘');
                let color = p.rank === 1 ? '#fbbf24' : (p.isBankrupt ? '#f87171' : 'white');
                rankHtml += `<div style="padding:10px;border-bottom:1px solid rgba(255,255,255,0.1);color:${color};">
                    <span style="font-weight:bold;width:50px;display:inline-block;">${status}</span>
                    <span>${p.name}</span>
                </div>`;
            });
            rankHtml += '</div>';
            rankHtml += '<button class="btn btn-primary" style="margin-top:20px;width:100%;" onclick="location.reload()">ğŸ”„ ë‹¤ì‹œ í•˜ê¸°</button>';

            document.getElementById('message').innerHTML = rankHtml;
            document.getElementById('message').style.minWidth = '300px';
        }

        // ì›ë³¸ ì˜¨ë¼ì¸ í•¨ìˆ˜ ë°±ì—… (ì´ë¦„ ë³€ê²½ìš©)
        const playSelectedCardsOnlineOriginal = function () {
            console.log('playSelectedCardsOnlineOriginal í˜¸ì¶œë¨, selectedCards:', selectedCards.length);

            if (selectedCards.length === 0) {
                console.log('ì„ íƒëœ ì¹´ë“œ ì—†ìŒ');
                return;
            }

            const myPlayer = players.find(p => p.isMe);
            if (!myPlayer) {
                console.log('myPlayer not found');
                return;
            }

            // ë‚´ í„´ì¸ì§€ í™•ì¸
            const currentPlayer = players[gameState.currentPlayerIndex];
            console.log('currentPlayerIndex:', gameState.currentPlayerIndex, 'isMe:', currentPlayer?.isMe);

            if (!currentPlayer || !currentPlayer.isMe) {
                alert('ë‹¹ì‹ ì˜ í„´ì´ ì•„ë‹™ë‹ˆë‹¤! (í˜„ì¬ í„´: ' + (currentPlayer?.name || 'ì•Œ ìˆ˜ ì—†ìŒ') + ')');
                return;
            }

            const cardsToPlay = selectedCards.map(i => myPlayer.hand[i]);
            const newHand = myPlayer.hand.filter((_, i) => !selectedCards.includes(i));

            // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
            const newDiscardPile = [...gameState.discardPile, ...cardsToPlay];
            const newDeck = [...gameState.deck];

            let newAttackStack = gameState.attackStack;
            let newAttackType = gameState.attackType;
            let newSkipTurns = gameState.skipTurns || 0;
            let newDirection = gameState.direction;

            // ë§ˆì§€ë§‰ ì¹´ë“œì˜ ë¬´ëŠ¬ ì‚¬ìš©
            const lastCard = cardsToPlay[cardsToPlay.length - 1];
            let newCurrentSuit = lastCard.suit;

            // ì¡°ì»¤ëŠ” ì´ì „ ë¬´ëŠ¬ ìœ ì§€
            if (lastCard.suit === 'black-joker' || lastCard.suit === 'color-joker') {
                newCurrentSuit = gameState.currentSuit;
            }

            console.log('ì¹´ë“œ ëƒ„:', cardsToPlay.map(c => c.suit + c.value).join(', '),
                'currentSuit ë³€ê²½:', gameState.currentSuit, '->', newCurrentSuit);

            playCardPlaySound(); // ì†Œë¦¬ ì¶”ê°€ (ì˜¨ë¼ì¸)

            // íŠ¹ìˆ˜ ì¹´ë“œ íš¨ê³¼
            const value = cardsToPlay[0].value;
            const count = cardsToPlay.length;

            const hasBlackJoker = cardsToPlay.some(c => c.suit === 'black-joker');
            const hasColorJoker = cardsToPlay.some(c => c.suit === 'color-joker');

            if (value === '2') {
                newAttackStack += 2 * count;
                newAttackType = '2';
            } else if (value === 'A') {
                newAttackStack += 3 * count;
                newAttackType = 'A';
            } else if (hasBlackJoker) {
                newAttackStack += 5 * count; // ì¡°ì»¤ ê³µê²©
                newAttackType = 'black-joker';
            } else if (hasColorJoker) {
                newAttackStack += 7 * count;
                newAttackType = 'color-joker';
            } else if (value === 'K') {
                const activeCount = players.filter(p => !p.isBankrupt && p.hand.length > 0).length;
                let kSkips = 0;

                if (activeCount <= 2) {
                    // 2ì¸: ì§ìˆ˜ ì¥(ë‚´ í„´), í™€ìˆ˜ ì¥(ìƒëŒ€ í„´)
                    kSkips = (count * 2);
                    if (count % 2 === 0) kSkips -= 1;
                } else {
                    // 3ì¸ ì´ìƒ: 1ì¥ë‹¹ 3ì¹¸ ì´ë™
                    kSkips = (count * 3) - 1;
                }

                newSkipTurns += kSkips;
                newAttackStack = 0;
                newAttackType = null;
            } else if (value === 'Q') {
                const activeCount = players.filter(p => !p.isBankrupt && p.hand.length > 0).length;
                if (activeCount <= 2) {
                    newSkipTurns += 1 * count;
                } else if (count % 2 === 1) {
                    newDirection *= -1;
                }
                newAttackStack = 0;
                newAttackType = null;
            } else if (value === 'J') {
                const activeCount = players.filter(p => !p.isBankrupt && p.hand.length > 0).length;
                let jSkips = 0;

                if (activeCount <= 2) {
                    jSkips = count;
                } else {
                    // 3ì¸ ì´ìƒ: 1ì¥ë‹¹ 2ì¹¸ ì´ë™
                    jSkips = (count * 2) - 1;
                }

                newSkipTurns += jSkips;
                newAttackStack = 0;
                newAttackType = null;
            } else {
                newAttackStack = 0;
                newAttackType = null;
            }

            // ë‹¤ìŒ í„´ ê³„ì‚°
            let nextPlayerIndex = gameState.currentPlayerIndex;
            const totalPlayers = players.length;

            // ìŠ¤í‚µ ì²˜ë¦¬
            // ê¸°ì¡´ 2ì¸ í´ë¨í”„ ì œê±°ë¨

            for (let i = 0; i <= newSkipTurns; i++) {
                nextPlayerIndex = (nextPlayerIndex + newDirection + totalPlayers) % totalPlayers;
                // íŒŒì‚°í•˜ê±°ë‚˜ ìŠ¹ë¦¬í•œ í”Œë ˆì´ì–´ ê±´ë„ˆë›°ê¸°
                let safety = 0;
                while ((players[nextPlayerIndex].isBankrupt || players[nextPlayerIndex].hand.length === 0) && safety < totalPlayers) {
                    nextPlayerIndex = (nextPlayerIndex + newDirection + totalPlayers) % totalPlayers;
                    safety++;
                }
            }
            newSkipTurns = 0;

            // 7ì¹´ë“œ ë¬´ëŠ¬ ì„ íƒì´ í•„ìš”í•œ ê²½ìš°
            if (value === '7' && cardsToPlay[0].suit !== 'black-joker' && cardsToPlay[0].suit !== 'color-joker') {
                document.getElementById('suit-selector').style.display = 'flex';
                // ì„ì‹œ ì €ì¥
                window.pendingUpdate = {
                    newHand, newDiscardPile, newDeck, newAttackStack, newAttackType,
                    newSkipTurns, newDirection, nextPlayerIndex
                };
                selectedCards = [];
                return;
            }

            // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (ì†íŒ¨ 0ì¥)
            let gameStatus = gameState.status || 'playing';
            let winner = null;

            if (newHand.length === 0) {
                gameStatus = 'finished';
                winner = myPlayerId;
            }

            // Firebase ì—…ë°ì´íŠ¸
            const updates = {
                deck: newDeck,
                discardPile: newDiscardPile,
                currentPlayerIndex: nextPlayerIndex,
                direction: newDirection,
                attackStack: newAttackStack,
                attackType: newAttackType,
                currentSuit: newCurrentSuit,
                skipTurns: 0,
                [`hands/${myPlayerId}`]: newHand
            };

            if (winner) {
                updates.status = 'finished';
                updates.winner = winner;
            }

            updateGameState(updates);

            // ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸
            selectedCards = [];
            document.getElementById('action-buttons').style.display = 'none';
        };

        const selectSuitOnlineOriginal = function (suit) {
            document.getElementById('suit-selector').style.display = 'none';
            if (window.pendingUpdate) {
                const { newHand, newDiscardPile, newDeck, newAttackStack, newAttackType,
                    newSkipTurns, newDirection, nextPlayerIndex } = window.pendingUpdate;

                // ì•Œë¦¼ ë©”ì‹œì§€ ìƒì„±
                const suitNames = { 'spade': 'â™  ìŠ¤í˜ì´ë“œ', 'heart': 'â™¥ í•˜íŠ¸', 'diamond': 'â™¦ ë‹¤ì´ì•„ëª¬ë“œ', 'club': 'â™£ í´ë¡œë²„' };
                const msg = `${myNickname}ë‹˜ì´ ë¬¸ì–‘ì„ [${suitNames[suit]}]ë¡œ ë°”ê¿¨ìŠµë‹ˆë‹¤!`;
                playSuitChangeSound(); // ì†Œë¦¬ ì¶”ê°€

                const updates = {
                    deck: newDeck,
                    discardPile: newDiscardPile,
                    currentPlayerIndex: nextPlayerIndex,
                    direction: newDirection,
                    attackStack: newAttackStack,
                    attackType: newAttackType,
                    currentSuit: suit,
                    skipTurns: 0,
                    lastAction: msg,
                    lastActionId: Date.now(),
                    [`hands/${myPlayerId}`]: newHand
                };

                // ìŠ¹ë¦¬ ì²´í¬ (ì†íŒ¨ê°€ 0ì¥ì´ë©´ ìŠ¹ë¦¬)
                if (newHand.length === 0) {
                    updates.status = 'finished';
                    updates.winner = myPlayerId;
                }

                updateGameState(updates);
                window.pendingUpdate = null;
            }
        };

        const drawCardOnlineOriginal = function () {
            const currentPlayer = players[gameState.currentPlayerIndex];
            if (!currentPlayer || !currentPlayer.isMe) {
                alert('ë‹¹ì‹ ì˜ í„´ì´ ì•„ë‹™ë‹ˆë‹¤!');
                return;
            }
            const myPlayer = players.find(p => p.isMe);
            if (!myPlayer) return;
            const cardsToDraw = gameState.attackStack > 0 ? gameState.attackStack : 1;
            const newDeck = [...gameState.deck];
            let newDiscardPile = [...gameState.discardPile];
            const newHand = [...myPlayer.hand];
            for (let i = 0; i < cardsToDraw; i++) {
                if (newDeck.length === 0) {
                    if (newDiscardPile.length <= 1) break; // ì„ì„ ì¹´ë“œê°€ ì—†ìœ¼ë©´ ì¤‘ë‹¨

                    const topCard = newDiscardPile[newDiscardPile.length - 1];
                    const reshuffled = newDiscardPile.slice(0, -1);
                    shuffle(reshuffled);
                    newDeck.push(...reshuffled);
                    newDiscardPile = [topCard]; // ë²„ë¦° ì¹´ë“œ ë”ë¯¸ ì´ˆê¸°í™” (ë§¨ ìœ„ 1ì¥ë§Œ ë‚¨ê¹€)
                }
                if (newDeck.length > 0) newHand.push(newDeck.pop());
            }
            let nextPlayerIndex = (gameState.currentPlayerIndex + gameState.direction + players.length) % players.length;

            // ì¡°ì»¤ ê³µê²© í›„ ì¹´ë“œë¥¼ ë¨¹ìœ¼ë©´ ë‹¤ìŒ ì‚¬ëŒì€ ì•„ë¬´ ì¹´ë“œë‚˜ ë‚¼ ìˆ˜ ìˆìŒ
            const wasJokerAttack = gameState.attackType === 'black-joker' || gameState.attackType === 'color-joker';
            const nextSuit = wasJokerAttack ? 'any' : gameState.currentSuit;

            // íŒŒì‚° ì²´í¬ (15ì¥ ì´ˆê³¼)
            const BANKRUPT_LIMIT = 15;
            let isBankrupt = newHand.length > BANKRUPT_LIMIT;

            const updates = {
                deck: newDeck,
                discardPile: newDiscardPile,
                currentPlayerIndex: nextPlayerIndex,
                attackStack: 0,
                attackType: null,
                currentSuit: nextSuit,
                [`hands/${myPlayerId}`]: isBankrupt ? [] : newHand
            };

            if (isBankrupt) {
                updates[`players/${myPlayerId}/isBankrupt`] = true;

                // í™œì„± í”Œë ˆì´ì–´ ìˆ˜ ì²´í¬
                const activePlayers = players.filter(p => !p.isBankrupt && p.hand.length > 0);
                // ë‚˜ë¥¼ ì œì™¸í•œ í™œì„± í”Œë ˆì´ì–´
                const remainingPlayers = activePlayers.filter(p => p.id !== myPlayerId);

                if (remainingPlayers.length === 1) {
                    // ë§ˆì§€ë§‰ ë‚¨ì€ ì‚¬ëŒì´ ìŠ¹ë¦¬
                    updates.status = 'finished';
                    updates.winner = remainingPlayers[0].id;
                }

                alert('ì¹´ë“œê°€ 15ì¥ì„ ì´ˆê³¼í•˜ì—¬ íŒŒì‚°í–ˆìŠµë‹ˆë‹¤! ğŸ˜±');
            }

            updateGameState(updates);
        };

        function showNotification(msg) {
            let el = document.getElementById('game-notification');
            if (!el) {
                // ë™ì  ìƒì„±
                el = document.createElement('div');
                el.id = 'game-notification';
                el.className = 'game-notification';
                document.body.appendChild(el);

                const style = document.createElement('style');
                style.innerHTML = `
        .game-notification {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fbbf24;
            padding: 12px 25px;
            border-radius: 30px;
            font-size: 1.1rem;
            z-index: 200;
            display: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            border: 2px solid #fbbf24;
            animation: slideDown 0.3s ease-out;
            white-space: nowrap;
            font-weight: bold;
        }
        @keyframes slideDown {
            from { top: 10%; opacity: 0; }
            to { top: 20%; opacity: 1; }
        }
                `;
                document.head.appendChild(style);
            }

            el.textContent = msg;
            el.style.display = 'block';

            if (window.notificationTimer) clearTimeout(window.notificationTimer);
            window.notificationTimer = setTimeout(() => {
                el.style.display = 'none';
            }, 5000);
        }
    </script>
</body>

</html>